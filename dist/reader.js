// Generated by CoffeeScript 1.3.3

/*
HELPERS
*/


(function() {
  var Boolean, Number, Token, read_token, to_type, tokenClasses,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  to_type = oppo.helpers.to_type;

  oppo.Token = Token = (function() {

    function Token(token_text) {
      this.token_text = token_text;
    }

    Token.prototype.add = function(list, lists) {
      var parsed;
      if (!this.ignore) {
        parsed = this.parse != null ? this.parse() : this;
        list.push(parsed);
      }
      return list;
    };

    Token.prototype.toString = function() {
      return this.token_text;
    };

    Token.match = function(text) {
      if (text === this.matcher) {
        return true;
      } else if ((to_type(this.matcher)) === "regexp") {
        return this.matcher.test(text);
      } else {
        return false;
      }
    };

    Token.make_matcher = function(m) {
      if ((to_type(m)) === "regexp") {
        return new RegExp("^" + m.source + "$");
      } else {
        return m;
      }
    };

    return Token;

  })();

  Number = (function(_super) {

    __extends(Number, _super);

    function Number() {
      return Number.__super__.constructor.apply(this, arguments);
    }

    Number.prototype.parse = function() {
      return +this.token_text;
    };

    return Number;

  })(Token);

  Boolean = (function(_super) {

    __extends(Boolean, _super);

    function Boolean() {
      return Boolean.__super__.constructor.apply(this, arguments);
    }

    return Boolean;

  })(Token);

  /*
  TOKEN DEFINITIONS
  */


  tokenClasses = [
    Token.Whitespace = (function(_super) {

      __extends(Whitespace, _super);

      function Whitespace() {
        return Whitespace.__super__.constructor.apply(this, arguments);
      }

      Whitespace.matcher = Token.make_matcher(/\s+/);

      Whitespace.prototype.ignore = true;

      return Whitespace;

    })(Token), Token.ListOpen = (function(_super) {

      __extends(ListOpen, _super);

      function ListOpen() {
        return ListOpen.__super__.constructor.apply(this, arguments);
      }

      ListOpen.matcher = "(";

      ListOpen.prototype.add = function(list, lists) {
        var new_list;
        new_list = [];
        list.push(new_list);
        lists.push(new_list);
        return new_list;
      };

      return ListOpen;

    })(Token), Token.ListClose = (function(_super) {

      __extends(ListClose, _super);

      function ListClose() {
        return ListClose.__super__.constructor.apply(this, arguments);
      }

      ListClose.matcher = ")";

      ListClose.prototype.add = function(list, lists) {
        lists.pop();
        return lists[lists.length - 1];
      };

      return ListClose;

    })(Token), Token.Fixnum = (function(_super) {

      __extends(Fixnum, _super);

      function Fixnum() {
        return Fixnum.__super__.constructor.apply(this, arguments);
      }

      Fixnum.matcher = Token.make_matcher(/-?\d+/);

      return Fixnum;

    })(Number), Token.Float = (function(_super) {

      __extends(Float, _super);

      function Float() {
        return Float.__super__.constructor.apply(this, arguments);
      }

      Float.matcher = Token.make_matcher(/-?\d*\.\d+/);

      return Float;

    })(Number), Token.String = (function(_super) {

      __extends(String, _super);

      function String() {
        return String.__super__.constructor.apply(this, arguments);
      }

      String.matcher = Token.make_matcher(/"[^"]*"/);

      String.prototype.parse = function() {
        return this.token_text.substr(1, this.token_text.length - 2);
      };

      return String;

    })(Token), Token.Nil = (function(_super) {

      __extends(Nil, _super);

      function Nil() {
        return Nil.__super__.constructor.apply(this, arguments);
      }

      Nil.matcher = "nil";

      Nil.prototype.parse = function() {
        return null;
      };

      return Nil;

    })(Token), Token.True = (function(_super) {

      __extends(True, _super);

      function True() {
        return True.__super__.constructor.apply(this, arguments);
      }

      True.matcher = "true";

      return True;

    })(Boolean), Token.False = (function(_super) {

      __extends(False, _super);

      function False() {
        return False.__super__.constructor.apply(this, arguments);
      }

      False.matcher = "false";

      return False;

    })(Boolean), Token.Symbol = (function(_super) {

      __extends(Symbol, _super);

      function Symbol(token_text) {
        if (token_text instanceof Token.Symbol) {
          token_text = token_text.token_text;
        }
        Symbol.__super__.constructor.call(this, token_text);
      }

      Symbol.matcher = Token.make_matcher(/[\w\-!@#$%^&*+=|\\:\/?<>\.]+/);

      return Symbol;

    })(Token)
  ];

  /*
  READER
  */


  read_token = function(text) {
    var TokenClass, match, matched, token_text, _i, _len;
    token_text = "";
    while (text.length) {
      token_text += text.charAt(0);
      text = text.substr(1);
      for (_i = 0, _len = tokenClasses.length; _i < _len; _i++) {
        TokenClass = tokenClasses[_i];
        matched = TokenClass.match(token_text);
        if (matched) {
          match = [new TokenClass(token_text), text];
          if (token_text === TokenClass.matcher) {
            return match;
          } else {
            break;
          }
        }
      }
      if (!matched && (match != null)) {
        return match;
      }
    }
    return match;
  };

  oppo.read = function(text) {
    var current_list, lists, token, token_stream, _ref;
    token_stream = [];
    lists = [token_stream];
    current_list = token_stream;
    while (text.length) {
      _ref = read_token(text), token = _ref[0], text = _ref[1];
      if (token != null) {
        current_list = token.add(current_list, lists);
      } else {
        throw new Error("ParseError: Invalid syntax: " + text);
      }
    }
    return token_stream;
  };

}).call(this);
