// Generated by CoffeeScript 1.3.3
(function() {
  var Context, ContextStack, JavaScriptCode, JavaScriptComment, Macro, Module, OppoCompileError, Splat, Symbol, anonymous_module_name, clone, compile, compile_list, compile_symbol, define, define_builtin_macro, define_macro, first_item_matches, gensym, get_module, get_symbol, get_symbol_text, is_keyword, is_quasiquoted, is_quoted, is_symbol, is_unquote_spliced, is_unquoted, lambda, module_splitter, symbol, text_to_js_identifier, to_type, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  JavaScriptCode = oppo.JavaScriptCode, JavaScriptComment = oppo.JavaScriptComment, Symbol = oppo.Symbol, Splat = oppo.Splat;

  _ref = oppo.helpers, text_to_js_identifier = _ref.text_to_js_identifier, to_type = _ref.to_type, clone = _ref.clone;

  Symbol.prototype.toString = function() {
    return get_symbol_text(this);
  };

  symbol = function(text, base_symbol) {
    if (text instanceof Symbol) {
      return text;
    } else {
      return new Symbol(text, base_symbol);
    }
  };

  get_symbol = function(sym) {
    var type;
    type = to_type(sym);
    if ((is_symbol(sym)) && type === "array") {
      if (is_quoted(sym)) {
        return get_symbol(sym[1]);
      } else {
        return sym[1];
      }
    } else if (type === "string") {
      return symbol(sym);
    } else if (sym instanceof Symbol) {
      return sym;
    } else {
      throw new Error("Can't get symbol from non-symbol " + sym);
    }
  };

  get_symbol_text = function(sym, resolve_module) {
    if (resolve_module == null) {
      resolve_module = false;
    }
    sym = get_symbol(sym);
    if (sym instanceof Symbol) {
      return text_to_js_identifier(sym.text);
    } else {
      throw new OppoCompileError("Can't get symbol text from non-symbol " + sym, sym);
    }
  };

  gensym = null;

  (function() {
    var gensym_id_map;
    gensym_id_map = {};
    return gensym = function(name) {
      var id, ret;
      if (name == null) {
        name = "gen";
      }
      id = gensym_id_map[name];
      if (!(id != null)) {
        id = gensym_id_map[name] = 0;
      }
      ret = symbol("" + name + "_" + id + "__");
      gensym_id_map[name] += 1;
      return ret;
    };
  })();

  module_splitter = null;

  get_module = function(sym) {
    var a_sym, module, s_sym;
    if (module_splitter == null) {
      module_splitter = text_to_js_identifier('::');
    }
    s_sym = get_symbol_text(sym, false);
    a_sym = s_sym.split(module_splitter);
    switch (a_sym.length) {
      case 1:
        s_sym = a_sym[0];
        break;
      case 2:
        module = a_sym[0], s_sym = a_sym[1];
        break;
      default:
        throw new OppoCompileError("Can't define more than one module for symbol " + s_sym, sym);
    }
    return [module, symbol(s_sym, sym)];
  };

  first_item_matches = function(x, sym) {
    var c_fst, c_sym, fst;
    c_sym = get_symbol_text(sym, true);
    if ((to_type(x)) === "array") {
      fst = x[0];
      if (is_symbol(fst)) {
        c_fst = get_symbol_text(fst);
        return c_fst === c_sym;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  is_symbol = function(x, recurse) {
    if (recurse == null) {
      recurse = true;
    }
    return x instanceof Symbol || (recurse && (to_type(x)) === "array" && is_symbol(compile_list(x, false), false));
  };

  is_keyword = function(x) {
    return first_item_matches(x, 'keyword');
  };

  is_quoted = function(x, recurse) {
    if (recurse == null) {
      recurse = true;
    }
    return (x != null ? x.quoted : void 0) || (recurse && (to_type(x)) === "array" && is_quoted(compile_list(x, false), false));
  };

  is_quasiquoted = function(x, recurse) {
    if (recurse == null) {
      recurse = true;
    }
    return (x != null ? x.quasiquoted : void 0) || (recurse && (to_type(x)) === "array" && is_quasiquoted(compile_list(x, false), false));
  };

  is_unquoted = function(x, recurse) {
    if (recurse == null) {
      recurse = true;
    }
    return (x != null ? x.unquoted : void 0) || (recurse && (to_type(x)) === "array" && is_unquoted(compile_list(x, false), false));
  };

  is_unquote_spliced = function(x, recurse) {
    if (recurse == null) {
      recurse = true;
    }
    return (x != null ? x.unquote_spliced : void 0) || (recurse && (to_type(x)) === "array" && is_unquote_spliced(compile_list(x, false), false));
  };

  OppoCompileError = (function(_super) {

    __extends(OppoCompileError, _super);

    function OppoCompileError(message, form) {
      this.form = form;
      this.line_number = this.form && this.form.line_number;
      if (this.line_number) {
        message = "at line " + this.line_number + ": " + message;
      }
      this.message = message;
    }

    return OppoCompileError;

  })(Error);

  Macro = (function() {

    function Macro(name, argnames, template) {
      this.name = name;
      if ((to_type(argnames)) === "function") {
        this.transform = argnames;
      } else {
        this.transform = eval((compile([symbol("lambda"), argnames].concat(__slice.call(template))))[0]);
      }
    }

    return Macro;

  })();

  Context = (function() {

    function Context(parent_context) {
      var _ref1, _ref2;
      this.parent_context = parent_context;
      this.context = clone((_ref1 = (_ref2 = this.parent_context) != null ? _ref2.context : void 0) != null ? _ref1 : Object.prototype);
    }

    Context.prototype.var_stmt = function() {
      var k, v, vars;
      vars = (function() {
        var _ref1, _results;
        _ref1 = this.context;
        _results = [];
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (!(v instanceof Context) && (to_type(v)) !== 'function') {
            _results.push(compile(symbol(k)));
          }
        }
        return _results;
      }).call(this);
      if (vars.length) {
        return "var " + (vars.join(', ')) + ";\n";
      } else {
        return "";
      }
    };

    Context.prototype.lookup = function(sym) {
      var core, module, new_sym, result, s_sym, _ref1, _ref2;
      _ref1 = get_module(sym), module = _ref1[0], new_sym = _ref1[1];
      if (module != null) {
        return (_ref2 = Module.get(module)) != null ? _ref2.lookup(new_sym) : void 0;
      }
      s_sym = get_symbol_text(new_sym);
      result = this.context[s_sym];
      if (!(module != null) && result === void 0 && (!(this instanceof Module) || this.name !== "core")) {
        core = Module.get('core');
        result = core.lookup(sym);
      }
      return result;
    };

    Context.prototype.def = function(sym, value) {
      var s_sym;
      s_sym = get_symbol_text(sym);
      if (!(this.context[s_sym] != null)) {
        return this.context[s_sym] = value;
      } else {
        throw new OppoCompileError("Can't define previously defined symbol: " + s_sym, sym);
      }
    };

    Context.prototype.set = function(sym, value) {
      var s_sym;
      s_sym = get_symbol_text(sym);
      if (this.context[s_sym] != null) {
        return this.context[s_sym] = value;
      } else {
        throw new OppoCompileError("Can't set value of undefined symbol: " + s_sym, sym);
      }
    };

    Context.prototype.get = function(sym) {
      var s_sym;
      s_sym = get_symbol_text(sym);
      return this.context[s_sym];
    };

    return Context;

  })();

  anonymous_module_name = "__anonymous__";

  Module = (function(_super) {

    __extends(Module, _super);

    function Module(parent_context, name) {
      var glob, _ref1;
      this.name = name;
      Module.set(this.name, this);
      Module.__super__.constructor.call(this, parent_context);
      glob = (_ref1 = oppo.context_stack) != null ? _ref1.global_context : void 0;
      if ((glob != null ? glob[this.name] : void 0) != null) {
        glob[this.name] = this;
      }
    }

    Module.modules = {};

    Module.get = function(name, create) {
      var m;
      m = this.modules[name];
      if (!(m != null)) {
        if (create) {
          m = new Module(null, name);
        } else {
          new OppoCompileError("Can't get undefined module: " + name);
        }
      }
      return m;
    };

    Module.set = function(name, module) {
      if ((this.modules[name] != null) && name !== anonymous_module_name) {
        throw new OppoCompileError("Can't make same module twice: " + name);
      } else {
        return this.modules[name] = module;
      }
    };

    return Module;

  })(Context);

  ContextStack = (function() {

    function ContextStack() {
      var mod, name;
      this.global_context = new Context();
      for (name in Module) {
        if (!__hasProp.call(Module, name)) continue;
        mod = Module[name];
        this.global_context[name] = mod;
      }
      this.stack = [this.global_context];
      this.current_context = this.global_context;
    }

    ContextStack.prototype.push = function(c) {
      this.current_context = c;
      this.stack.push(c);
      return c;
    };

    ContextStack.prototype.push_new = function() {
      var c;
      c = new Context(this.current_context);
      return this.push(c);
    };

    ContextStack.prototype.push_new_module = function(name) {
      var m;
      m = new Module(this.current_context, name);
      return this.push(m);
    };

    ContextStack.prototype.pop = function() {
      var c;
      c = this.stack.pop();
      this.current_context = this.stack[this.stack.length - 1];
      return c;
    };

    return ContextStack;

  })();

  compile = function() {
    var compiled, parse_tree, result, sexp, sexp_type, _i, _len;
    parse_tree = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    compiled = [];
    for (_i = 0, _len = parse_tree.length; _i < _len; _i++) {
      sexp = parse_tree[_i];
      sexp_type = to_type(sexp);
      result = !(sexp != null) || sexp instanceof Macro ? "null" : sexp instanceof JavaScriptComment ? void 0 : sexp instanceof JavaScriptCode ? sexp.text : sexp instanceof Symbol ? compile_symbol(sexp) : sexp_type === "boolean" || sexp_type === "number" ? "" + sexp : sexp_type === "string" ? "\"" + sexp + "\"" : sexp_type === "array" ? compile_list(sexp) : void 0;
      if (result !== void 0) {
        compiled.push(result);
      }
    }
    return compiled;
  };

  oppo.compile = function(parse_tree, module_name) {
    var c, module, var_stmt, _ref1;
    if (module_name == null) {
      module_name = anonymous_module_name;
    }
    if ((_ref1 = oppo.context_stack) == null) {
      oppo.context_stack = new ContextStack();
    }
    module = oppo.context_stack.push_new_module(module_name);
    c = compile.apply(null, parse_tree);
    oppo.context_stack.pop();
    var_stmt = module.var_stmt();
    return "(function () {\n\n" + var_stmt + "return " + (c.join(",\n")) + ";\n\n})();";
  };

  compile_symbol = function(sym, resolve_module) {
    var module, new_sym, sym_text, value, _ref1, _ref2;
    if (resolve_module == null) {
      resolve_module = true;
    }
    sym_text = (to_type(sym)) === "string" ? sym : sym.text;
    if (sym.quoted) {
      return "new oppo.Symbol(\"" + sym_text + "\")";
    } else {
      if (resolve_module) {
        _ref1 = get_module(sym), module = _ref1[0], new_sym = _ref1[1];
      }
      value = (_ref2 = oppo.context_stack) != null ? _ref2.current_context.lookup(sym) : void 0;
      if (value instanceof Macro) {
        return value;
      } else if (module != null) {
        return [symbol("object-get-value"), symbol(module), new_sym];
      } else {
        return text_to_js_identifier(sym_text);
      }
    }
  };

  compile_list = function(ls, to_compile) {
    var c_callable, c_ls, callable, callable_is_keyword, callable_is_quoted, callable_is_symbol, compiled_item, concat_args, lists, quasiquoted, quote_symbol, result, x, _i, _len;
    if (to_compile == null) {
      to_compile = true;
    }
    if (ls.quoted) {
      quasiquoted = ls.quasiquoted;
      quote_symbol = symbol(quasiquoted ? 'quasiquote' : 'quote');
      c_ls = [];
      lists = [c_ls];
      for (_i = 0, _len = ls.length; _i < _len; _i++) {
        x = ls[_i];
        if (!quasiquoted || !is_unquoted(x)) {
          c_ls.push((compile([quote_symbol, x]))[0]);
        } else {
          compiled_item = (compile(x))[0];
          if (is_unquote_spliced(x)) {
            c_ls = [];
            lists.push(compiled_item, c_ls);
          } else {
            c_ls.push(compiled_item);
          }
        }
      }
      concat_args = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = lists.length; _j < _len1; _j++) {
          ls = lists[_j];
          if ((to_type(ls)) === "array") {
            _results.push("[" + (ls.join(', ')) + "]");
          } else {
            _results.push(ls);
          }
        }
        return _results;
      })();
      if (concat_args.length > 1) {
        return "" + concat_args[0] + ".concat(" + (concat_args.slice(1).join(', ')) + ")";
      } else {
        return concat_args[0];
      }
    } else if (ls.quasiquoted) {
      c_ls = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = ls.length; _j < _len1; _j++) {
          x = ls[_j];
          if (!is_unquoted(x)) {
            _results.push((compile([symbol('quasiquote'), x]))[0]);
          }
        }
        return _results;
      })();
      return "";
    } else {
      callable = ls[0];
      callable_is_keyword = is_keyword(callable);
      callable_is_quoted = is_quoted(callable);
      callable_is_symbol = is_symbol(callable);
      if (!(callable_is_keyword || callable_is_quoted)) {
        if ((to_type(callable)) === "array") {
          c_callable = compile_list(callable, false);
        } else {
          c_callable = (compile(callable))[0];
        }
      }
      if (!callable_is_quoted && callable_is_symbol) {
        if (!(c_callable instanceof Macro)) {
          c_callable = Module.get('core').get('call');
          ls[0] = callable;
        } else {
          ls = ls.slice(1);
        }
        if (!(c_callable instanceof Macro)) {
          throw new OppoCompileError("Can't call list: " + ls, ls);
        }
      } else if (callable_is_keyword || (callable_is_symbol && callable_is_quoted)) {
        c_callable = Module.get('core').get('object-get-value');
      } else {
        c_callable = Module.get('core').get('call');
      }
      result = c_callable.transform.apply(c_callable, ls);
      if (to_compile) {
        return (compile(result))[0];
      } else {
        return result;
      }
    }
  };

  lambda = function() {
    var arg, args, body, body_len, c_args, c_body, context, found_splat, is_splat, normal_args, return_kywd, splat_arg, splat_arg_val, splat_args, var_stmt, _i, _len;
    args = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    context = oppo.context_stack.push_new();
    splat_args = [];
    normal_args = [];
    found_splat = false;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      is_splat = arg instanceof Splat;
      found_splat || (found_splat = is_splat);
      if (is_splat) {
        continue;
      }
      if (found_splat) {
        splat_args.push(arg);
      } else {
        normal_args.push(arg);
      }
    }
    if (splat_args.length > 1) {
      throw new OppoCompileError("Oppo currently does not support having more than one rest argument.");
    }
    args = normal_args;
    splat_arg = splat_args[0];
    body_len = body.length;
    if (splat_arg != null) {
      splat_arg_val = new JavaScriptCode("Array.prototype.slice.call(arguments, " + args.length + ")");
      body = [[symbol('def'), splat_arg, splat_arg_val]].concat(__slice.call(body));
    }
    c_args = compile.apply(null, args);
    c_body = compile.apply(null, body);
    oppo.context_stack.pop();
    var_stmt = context.var_stmt();
    return_kywd = body_len ? "return " : "";
    return new JavaScriptCode("(function (" + (c_args.join(', ')) + ") {\n  " + var_stmt + return_kywd + (c_body.join(',\n')) + ";\n})");
  };

  define = function() {
    var args, body, c_name, c_val, context, module, name, others, value, _ref1, _ref2;
    name = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((to_type(name)) === "array") {
      _ref1 = name, name = _ref1[0], args = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
      body = others;
      return define(name, [symbol('lambda'), args].concat(__slice.call(body)));
    } else {
      value = others[0];
    }
    _ref2 = get_module(name), module = _ref2[0], name = _ref2[1];
    if (module != null) {
      context = Module.get(module, true);
    } else {
      context = oppo.context_stack.current_context;
    }
    context.def(name, value);
    c_name = compile(name)[0];
    c_val = compile(value)[0];
    return new JavaScriptCode("" + c_name + " = " + c_val);
  };

  define_macro = function(name, argnames, template) {
    var value;
    value = new Macro(name, argnames, template);
    define(name, value);
    return void 0;
  };

  define_builtin_macro = function(name, template_compile) {
    return define_macro(symbol(name), template_compile);
  };

  define_builtin_macro("core::defmacro", function() {
    var argnames, args, name, template;
    args = arguments[0], template = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    name = args[0], argnames = 2 <= args.length ? __slice.call(args, 1) : [];
    return define_macro(name, argnames, template);
  });

  define_builtin_macro("core::def", define);

  define_builtin_macro("core::lambda", lambda);

  define_builtin_macro("core::call", function() {
    var args, c_args, c_fname, fname;
    fname = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    c_fname = compile(fname)[0];
    c_args = compile.apply(null, args);
    return new JavaScriptCode("" + c_fname + "(" + (c_args.join(', ')) + ")");
  });

  define_builtin_macro("core::object-get-value", function(prop, base) {
    var c_base, c_prop, js_code, s_prop;
    c_base = (compile(base))[0];
    if ((is_quoted(prop)) && (is_symbol(prop))) {
      s_prop = compile_list(prop, false);
      s_prop.quoted = false;
      c_prop = (compile(s_prop))[0];
      js_code = "" + c_base + "." + c_prop;
    } else {
      c_prop = (compile(prop))[0];
      js_code = "" + c_base + "[" + c_prop + "]";
    }
    return new JavaScriptCode(js_code);
  });

  define_builtin_macro("core::.", function() {
    var args, base, fname;
    fname = arguments[0], base = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    fname = [symbol('quote'), fname];
    return [[symbol('object-get-value'), fname, base]].concat(__slice.call(args));
  });

  define_builtin_macro("core::keyword", function(k) {
    return k;
  });

  define_builtin_macro("core::quote", function(x) {
    if (x != null) {
      x.quoted = true;
    }
    return x;
  });

  define_builtin_macro("core::quasiquote", function(x) {
    if (x != null) {
      x.quasiquoted = true;
    }
    return [symbol("quote"), x];
  });

  define_builtin_macro("core::unquote", function(x) {
    if (x != null) {
      x.unquoted = true;
    }
    return x;
  });

  define_builtin_macro("core::unquote-splicing", function(x) {
    if (x != null) {
      x.unquote_spliced = true;
    }
    return [symbol("unquote"), x];
  });

  define_builtin_macro("js::eval", function(to_eval) {
    var quotes_escaped, s_to_eval, type;
    type = to_type(to_eval);
    if (type === "string") {
      quotes_escaped = to_eval.replace(/"/g, '\\"');
      s_to_eval = "\"" + quotes_escaped + "\"";
      return new JavaScriptCode(eval(s_to_eval));
    } else {
      return [symbol("eval"), (compile(to_eval))[0]];
    }
  });

}).call(this);
