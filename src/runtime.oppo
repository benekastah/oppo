;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo 'eval) ~sexp))

(defmacro print (...things)
  `((. console 'log) ...things))
  
(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))
  
;(defmacro or (...items)
;  (let (s ((. items 'join) " || "))
;    `(js-eval ~s)))
    
;(defmacro and)

;(defmacro apply)

(defn (. window 'js-type) (x)
  (let (cls ((. Object 'prototype 'toString 'call) x)
        type-arr ((. cls 'match) #/\s([a-zA-Z]+)/)
        type (. type-arr 1))
    ((. type 'toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections

; nth needs to be able to detect if 0 is passed in, and then throw an error
; nth needs to be able to detect if n is not a number, in which case do the calculation at runtime
(defmacro nth (a n)
  (if (=== (js-type n) "number")
    (if (not=== n 0)
      `(. ~a ~(- n 1))
      (throw "nth treats collections as one-based; cannot get zeroth item"))
    `(. ~a (- ~n 1))))
  
(defmacro first (a)
  `(nth ~a 1))
  
(defmacro second (a)
  `(nth ~a 2))
  
(defmacro last (a)
  `(nth ~a (. ~a 'length)))

(defmacro concat (base ...items)
  `((. ~base 'concat) ...items))
  
(defmacro join (a s)
  `((. ~a 'join) ~s))

;; Lists

;; Strings
(defmacro replace (base ...items)
  `((. ~base 'replace) ...items))

(defmacro str (...items)
  (let (new-items (concat ["\""] items "\"")
        s ((. new-items join) "\" + \""))
    `(js-eval ~(replace s " + \"\"" ""))))


;; Set up underscore
(let (collections [ :each :map :reduce :reduceRight :find :filter :reject :all 
                    :any :include :invoke :pluck :max :min :sortBy :groupBy 
                    :sortedIndex :shuffle :toArray :size]
      arrays [:first :initial :last :rest :compact :flatten :without :union 
              :intersection :difference :uniq :zip :indexOf :lastIndexOf :range]
      functions [ :bind :bindAll :memoize :delay :defer :throttle :debounce 
                  :once :after :wrap :compose]
      objects [ :keys :values :functions :extend :defaults :clone :tap :isEqual 
                :isEmpty :isElement :isArray :isArguments :isFunction :isString 
                :isNumber :isBoolean :isDate :isRegExp :isNaN :isNull :isUndefined]
      utility [:noConflict :identity :times :mixin :uniqueId :escape :template]
      chaining [:chain :value])
  
  ;(defn dasherize (s)
  ;  ((. s replace) #//))
  
  ;; Add all the underscore methods here
  )