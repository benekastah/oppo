;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo eval) ~sexp))

(defmacro print (...things)
  `((. console log) ...things))
  
(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))
  
(defmacro or (...items)
  (let (s ((. items join) " || "))
    `(js-eval ~s)))

;(defmacro apply)

(defn typeof (x)
  (let (cls ((. Object prototype toString call) x)
        type-arr ((. cls match) #/\s([a-zA-Z]+)/)
        type ((. - first) type-arr))
    ((. type toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections
(defmacro concat (base ...items)
  `((. ~base concat) ...items))

;; Lists

;; Strings
; (defmacro str (...items)
;   (let (new-items (concat ["\""] items "\"")
;         s ((. new-items join) "\" + \""))
;     `(js-eval ~((. s replace) " + \"\"" ""))))

;; Arithmetic
;(defmacro + (...nums)
;  )



;; Set up underscore
(let (collections [:each :map :reduce :reduceRight :find :filter :reject :all :any :include :invoke :pluck :max :min :sortBy :groupBy :sortedIndex :shuffle :toArray :size]
      arrays [:first :initial :last :rest :compact :flatten :without :union :intersection :difference :uniq :zip :indexOf :lastIndexOf :range]
      functions [:bind :bindAll :memoize :delay :defer :throttle :debounce :once :after :wrap :compose]
      objects [:keys :values :functions :extend :defaults :clone :tap :isEqual :isEmpty :isElement :isArray :isArguments :isFunction :isString :isNumber :isBoolean :isDate :isRegExp :isNaN :isNull :isUndefined]
      utility [:noConflict :identity :times :mixin :uniqueId :escape :template]
      chaining [:chain :value])
  
  ;(defn dasherize (s)
  ;  ((. s replace) #//))
  
  ;; Add all the underscore methods here
  )