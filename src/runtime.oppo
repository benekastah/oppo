;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo 'eval) ~sexp))
  
(defmacro read (s)
  `((. oppo 'read) ~s))

(defmacro println (...things)
  `((. console 'log) ...things))

(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))

(defn identity (x) x)

;; Global definitions
(def ->bool identity)

(def global (if (undefined? global) window global))

(defmacro gdef (nm value)
  `(def (. global (quote ~nm)) ~value))
  
(if (. global 'global) () (gdef global global))
(gdef identity identity)
  
(defmacro gdefn (nm argslist ...body)
  `(gdef ~nm (lambda ~argslist ...body)))

(gdefn println (...things)
  (apply (. console 'log) things))

;; Type conversion
(gdefn ->bool (x)
  (js-eval "!(x == null || x === false || x === \"\" || x !== x)"))

(gdefn ->num (n)
  ((. window :Number) n))

(gdefn ->str (s)
  (str s))

;; Binary functions
(gdefn not (x)
  (let (bx (->bool x))
    (js-eval "!bx")))

(let (binary-each
        (lambda (type ls)
          (let (item (nth ls 1))
            (if (|| (&& (=== type :or) (->bool item))
                    (&& (=== type :and) (not item))
                    (=== (. ls 'length) 0))
              item
              (binary-each type ((. ls 'slice) 1))))))
                
  (gdefn or (...items)
    (binary-each :or items))
    
  (gdefn and (...items)
    (binary-each :and items)))

(gdefn js-type (x)
  (let (cls ((. Object :prototype :toString :call) x)
        type-arr ((. cls 'match) #/\s([a-zA-Z]+)/)
        type (. type-arr 1))
    ((. type 'toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections    
(gdefn nth (a n)
  (if (=== n 0)
    (throw "nth treats collections as one-based; cannot get zeroth item"))
  (let (i (if (< n 0)
            (+ (. a 'length) n)
            (- n 1)))
    (. a i)))
  
(gdefn first (a) (nth a 1))
  
(gdefn second (a) (nth a 2))
  
(gdefn last (a) (nth a -1))

(gdefn concat (base ...items)
  (apply (. base 'concat) ...items))
  
(gdefn join (a s)
  ((. a 'join) s))
  
;(defmacro slice ())

;; Lists

;; Strings
(defmacro replace (base ...items)
  `((. ~base 'replace) ...items))
  
(defmacro remove (base pattern)
  `(replace base pattern ""))
  
(defmacro match (base pattern)
  `((. ~base 'match) pattern))

;; Regex
(defmacro re-match ())

;; Math
(gdefn + (...nums)
  ())

;; Set up underscore
(let (underscore-methods 
          ;; collections
        [ ;:each 
          :map :reduce :reduceRight :find :filter :reject :all 
                    :any :include :invoke :pluck :max :min :sortBy :groupBy 
                    :sortedIndex :shuffle :toArray :size
          ;; arrays
          :first :initial :last :rest :compact :flatten :without :union 
              :intersection :difference :uniq :zip :indexOf :lastIndexOf :range
          ;; functions
          :bind :bindAll :memoize :delay :defer :throttle :debounce 
                    :once :after :wrap :compose
          ;; objects
          :keys :values :functions :extend :defaults :clone :tap :isEqual 
                    :isEmpty :isElement :isArray :isArguments :isFunction :isString 
                    :isNumber :isBoolean :isDate :isRegExp :isNaN :isNull
                    ;:isUndefined
          ;; utility
          :noConflict :identity :times :mixin :uniqueId :escape :template
          ;; chaining
          :chain :value])
  
  (defmacro -get (m)
    `(. - ~m))
  
  (gdef = (-get :isEqual))
  (gdef each (-get :each))
  
  (defn dasherize (s)
    (replace s #/([a-z])([A-Z])/ "$1-$2"))
    
  (defmacro symbolize (s)
    (let (dashed (dasherize s)
          replaced-is (replace dashed #/^is\-(.*)$/ "$1?")
          replaced-to (if (not=== replaced-is dashed)
                        (replace replaced-is #/^to\-(.*)$/ "->$1")
                        replaced-is))
      `(symbol ~replaced-to)))
      
  (each underscore-methods
    (lambda (nm)
      (gdef (symbolize nm) (-get nm))))
  
  ;; Add all the underscore methods here
  )