;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo 'eval) ~sexp))
  
(defmacro read (s)
  `((. oppo 'read) ~s))

(defmacro print (...things)
  `((. console 'log) ...things))
  
(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))
  
(defmacro apply (fn ...args)
  (let (args-list ((. window :Array 'prototype 'concat 'apply) [] args))
    `(~fn ...args-list)))
  
;; Type conversion
(defn (. window '->bool) (x)
  (js-eval "!(x == null || x === false || x === \"\" || x !== x)"))
  
(defn (. window '->num) (n)
  ((. window :Number) n))
  
(defn (. window '->str) (s)
  (str s))

;; Binary functions
(defn (. window 'not) (x)
  (let (bx (->bool x))
    (js-eval "!bx")))

(let (binary-each
        (lambda (type ls)
          (let (item (nth ls 1))
            (if (|| (&& (=== type :or) (->bool item))
                    (&& (=== type :and) (not item))
                    (=== (. ls 'length) 0))
              item
              (binary-each type ((. ls 'slice) 1))))))
                
  (defn (. window 'or) (...items)
    (binary-each :or items))
    
  (defn (. window 'and) (...items)
    (binary-each :and items)))

;(defmacro apply)

(def global (|| global window))

(defmacro defg )

(defn (. window 'js-type) (x)
  (let (cls ((. Object :prototype :toString :call) x)
        type-arr ((. cls 'match) #/\s([a-zA-Z]+)/)
        type (. type-arr 1))
    ((. type 'toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections    
(defn (. window 'nth) (a n)
  (if (=== n 0)
    (throw "nth treats collections as one-based; cannot get zeroth item"))
  (let (i (if (< n 0)
            (+ (. a 'length) n)
            (- n 1)))
    (. a i)))
  
(defn (. window 'first) (a) (nth a 1))
  
(defn (. window 'second) (a) (nth a 2))
  
(defn (. window 'last) (a) (nth a -1))

(defn (. window 'concat) (base ...items)
  (apply (. base 'concat) ...items))
  
(defn (. window 'join) (a s)
  ((. a 'join) s))
  
(defmacro slice ())

;; Lists

;; Strings
(defmacro replace (base ...items)
  `((. ~base 'replace) ...items))
  
(defmacro remove (base pattern)
  `(replace base pattern ""))


;; Set up underscore
(let (collections [ :each :map :reduce :reduceRight :find :filter :reject :all 
                    :any :include :invoke :pluck :max :min :sortBy :groupBy 
                    :sortedIndex :shuffle :toArray :size]
      arrays [:first :initial :last :rest :compact :flatten :without :union 
              :intersection :difference :uniq :zip :indexOf :lastIndexOf :range]
      functions [ :bind :bindAll :memoize :delay :defer :throttle :debounce 
                  :once :after :wrap :compose]
      objects [ :keys :values :functions :extend :defaults :clone :tap :isEqual 
                :isEmpty :isElement :isArray :isArguments :isFunction :isString 
                :isNumber :isBoolean :isDate :isRegExp :isNaN :isNull :isUndefined]
      utility [:noConflict :identity :times :mixin :uniqueId :escape :template]
      chaining [:chain :value])
  
  (defmacro -get (m)
    `(. - ~m))
  
  (def (. window '=) (-get :isEqual))
  
  ;(defn dasherize (s)
  ;  (. (replace s #/([a-z])([A-Z])/ "$1-$2") :toLowerCase))
    
  ;(defn symbolize (s)
  ;  (if ()))
  
  ;; Add all the underscore methods here
  )