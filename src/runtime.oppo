;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo 'eval) ~sexp))
  
(defmacro read (s)
  `((. oppo 'read) ~s))

(defmacro print (...things)
  `((. console 'log) ...things))
  
(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))
  
(defn (. window '->bool) (x)
  (if (|| (== x nil) (=== x #f) (=== x "") (not=== x x))
    #f
    #t))
    
(defn (. window '->num) (n)
  ((. window :Number) n))
  
(defn (. window '->str) (s)
  (str s))

(defn not (x) (js-eval "!x"))

(let (binary-each (lambda (type ls)
                (let (item (nth ls 1))
                  (if (|| (&& (=== type :or) item)
                          (&& (=== type :and) (not item)))
                    item
                    (if (> (. ls 'length) 0)
                      (binary-each type ((. ls 'slice) 1))
                      nil)))))
  (defn (. window 'or) (...items)
    (binary-each :or items))
    
  (defn (. window 'and) (...items)
    (binary-each :and items)))

;(defmacro apply)

(def global (|| global window))

(defmacro defg )

(defn (. window 'js-type) (x)
  (let (cls ((. Object :prototype :toString :call) x)
        type-arr ((. cls 'match) #/\s([a-zA-Z]+)/)
        type (. type-arr 1))
    ((. type 'toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections    
(defn (. window 'nth) (a n)
  (if (=== n 0)
    (throw "nth treats collections as one-based; cannot get zeroth item"))
  (let (i (if (< n 0)
            (+ (. a 'length) n)
            (- n 1)))
    (. a i)))
  
(defmacro first (a)
  `(nth ~a 1))
  
(defmacro second (a)
  `(nth ~a 2))
  
(defmacro last (a)
  `(nth ~a -1))

(defmacro concat (base ...items)
  `((. ~base 'concat) ...items))
  
(defmacro join (a s)
  `((. ~a 'join) ~s))

;; Lists

;; Strings
(defmacro replace (base ...items)
  `((. ~base 'replace) ...items))
  
(defmacro remove (base pattern)
  `(replace base pattern ""))


;; Set up underscore
(let (collections [ :each :map :reduce :reduceRight :find :filter :reject :all 
                    :any :include :invoke :pluck :max :min :sortBy :groupBy 
                    :sortedIndex :shuffle :toArray :size]
      arrays [:first :initial :last :rest :compact :flatten :without :union 
              :intersection :difference :uniq :zip :indexOf :lastIndexOf :range]
      functions [ :bind :bindAll :memoize :delay :defer :throttle :debounce 
                  :once :after :wrap :compose]
      objects [ :keys :values :functions :extend :defaults :clone :tap :isEqual 
                :isEmpty :isElement :isArray :isArguments :isFunction :isString 
                :isNumber :isBoolean :isDate :isRegExp :isNaN :isNull :isUndefined]
      utility [:noConflict :identity :times :mixin :uniqueId :escape :template]
      chaining [:chain :value])
  
  (defmacro -get (m)
    `(. - ~m))
  
  (def (. window '=) (-get :isEqual))
  
  ;(defn dasherize (s)
  ;  (. (replace s #/([a-z])([A-Z])/ "$1-$2") :toLowerCase))
    
  ;(defn symbolize (s)
  ;  (if ()))
  
  ;; Add all the underscore methods here
  )