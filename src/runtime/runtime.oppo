(def global (if (defined? window) window global))

(if (undefined? (. global 'global))
  (def (. global 'global) global)
  (set! (. global 'global) global))

(defmacro gdef (nm value)
  `(def (. global (quote ~nm)) ~value))

(defmacro defn (nm argslist ...body)
  `(def ~nm (lambda ~argslist ...body)))
  
(defmacro gdefn (nm argslist ...body)
  `(gdef ~nm (lambda ~argslist ...body)))

(defmacro defmodule (nm deps ...body)
  (let (-deps (|| deps [])
        -deps ((. - 'map) -deps #(str (. %1 1))))
    `((. oppo 'module) ~(. nm 1) '~-deps #(do ...body))))

;; Logging / Printing
(defmacro log (...things)
  `((. console 'log) ...things))

(defmacro print (item)
  (let (x (gensym))
    `(let (~x ~item)
      (log ~x)
      ~x)))

;; Misc macros and functions
(defmacro eval (sexp)
  `((. oppo 'eval) ~sexp))
  
(defmacro read (s)
  `((. oppo 'read) ~s))

(defmacro log (...things)
  `((. console 'log) ...things))

;; Global definitions
(def ->bool (. - 'identity))

(gdefn println (...things)
  (apply (. console 'log) things))

;; Type conversion
(gdefn ->bool (x)
  (js-eval "!(x == null || x === false || x === \"\" || x !== x)"))

(gdefn ->num (n)
  ((. global :Number) n))

(gdefn ->str (s)
  (str s))

;; Binary functions
(gdefn not (x)
  (let (bx (->bool x))
    (js-eval "!bx")))

(let (binary-each
        (lambda (type ls)
          (let (item (nth ls 1))
            (if (|| (&& (=== type :or) (->bool item))
                    (&& (=== type :and) (not item))
                    (=== (. ls 'length) 0))
              item
              (binary-each type ((. ls 'slice) 1))))))
                
  (gdefn or (...items)
    (binary-each :or items))
    
  (gdefn and (...items)
    (binary-each :and items)))

(gdefn js-type (x)
  (let (cls ((. Object :prototype :toString :call) x)
        type-arr ((. cls 'match) #/\s([a-zA-Z]+)/)
        type (. type-arr 1))
    ((. type 'toLowerCase))))

;(defmacro .. (...items)
;  (if (= 2 (size items))
;    ))

;; Collections    
(gdefn nth (a n)
  (if (=== n 0)
    (throw "nth treats collections as one-based; cannot get zeroth item"))
  (let (i (if (< n 0)
            (+ (. a 'length) n)
            (- n 1)))
    (. a i)))
  
(gdefn first (a) (nth a 1))
  
(gdefn second (a) (nth a 2))
  
(gdefn last (a) (nth a -1))

(gdefn concat (base ...items)
  (apply (. base 'concat) ...items))
  
(gdefn join (a s)
  ((. a 'join) s))
  
;(defmacro slice ())

;; Lists

;; Strings
(defmacro replace (base ...items)
  `((. ~base 'replace) ...items))
  
(defmacro remove (base pattern)
  `(replace base pattern ""))
  
(defmacro match (base pattern)
  `((. ~base 'match) pattern))

;; Regex
(defmacro re-match ())

;; Math
(gdefn + (...nums)
  ())

;; Set up underscore
; (let (_fn (fn (source-name target-names)
;             (let (targets (if (> (. target-names 'length) 0) target-names [source-name]))
;               ((. - 'each)  targets
;                             (fn (nm)
;                               (def (. global nm) (. - source-name))))))
;       _fns (fn (name-map)
;             (apply (. - 'each) name-map _fn)))
;   
;   (_fns { ;; Collections
;           :each []
;           :map []
;           :reduce ['reduce 'foldl]
;           :reduceRight ['reduce-right 'foldr]
;           :find []
;           :filter []
;           :reject []
;           :all []
;           :any []
;           :include []
;           :invoke []
;           :pluck []
;           ; :max []
;           ; :min []
;           :sortBy ['sort-by]
;           :groupBy ['group-by]
;           :sortedIndex ['sorted-index]
;           :suffle []
;           :toArray ['->array]
;           :size []
;           
;           ;; Arrays
;           :first ['first 'head]
;           :initial ['initial 'init]
;           :last []
;           :rest ['rest 'tail]
;           :compact []
;           :flatten []
;           :without []
;           :union []
;           :intersection []
;           :difference []
;           :uniq []
;           :zip []
;           :indexOf ['index-of]
;           :lastIndexOf ['last-index-of]
;           :range []
;           
;           ;; Functions
;           :bind []
;           :bindAll ['bind-all]
;           :memoize []
;           :delay []
;           :defer []
;           :throttle []
;           :debounce []
;           :once []
;           :after []
;           :wrap []
;           :compose []
;           
;           ;; Objects
;           :keys []
;           :values []
;           :functions []
;           :extend []
;           :defaults []
;           :clone []
;           :tap []
;           :isEqual ['equal? '=]
;           :isEmpty ['empty?]
;           :isElement ['element?]
;           :isArray ['array?]
;           :isArguments ['arguments?]
;           :isFunction ['function?]
;           :isNumber ['number?]
;           :isBoolean ['boolean? 'bool?]
;           :isDate ['date?]
;           :isRegExp ['regex?]
;           :isNaN ['nan?]
;           :isNull ['nil?]
;           :isUndefined ['undefined?]
;           
;           ;; Utility
;           ; :noConflict []
;           :identity []
;           :times []
;           :uniqueId ['unique-id]
;           :escape []
;           :template []
;           
;           ;; Chaining
;           :chain []
;           :value []}))