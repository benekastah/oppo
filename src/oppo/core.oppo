(include test)

(def global ('root oppo))
(def typeof ('to-type ('helpers oppo)))

(def eval ('eval oppo))

(defmacro (def-infix-op-fn name ...op)
  `(let (op (lambda (a b) ,@op))
     (def (,name)
          (reduce op (js::eval "arguments")))))

(defmacro (def-chained-operator name op joiner)
  (let (unqt (lambda (x) `(unquote ,x))
        unqt-spl (lambda (x) `(unquote-splicing ,x)))
    `(defmacro (,name ...args)
       (let (len ('length args))
         (if len
             (let (a (js::eval "args[0]"))
               (if (js::eval "len > 1")
                   (let (a* (.compile-item oppo a)
                            b (.compile-item oppo (js::eval "args[1]"))
                            list* (lambda (...ls) ls)
                            compiled (.join (list* a* ,op b) " ")
                            name ',name
                            joiner ',joiner
                            joiner (if joiner joiner name)
                            joiner-is-name (js::eval "name.text == joiner.text")
                            rest (if joiner-is-name
                                     (js::eval "args.slice(2)")
                                     (js::eval "args.slice(1)"))
                            rest (if joiner-is-name
                                     rest
                                     (if (js::eval "rest.length > 1")
                                         (list* (concat (list* name) rest))
                                         '())))
                     `(,(unqt 'joiner) (js::eval ,(unqt 'compiled)) ,(unqt-spl 'rest)))
                   a)))))))


(defmacro (apply fn args)
  `(.apply ,fn #nil ,args))


;; Math
(def-chained-operator + "+")
(def-chained-operator - "-")
(def-chained-operator * "*")
(def-chained-operator / "/")
;; (def-infix-op-fn + (js::eval "(+a) + (+b)"))
;; (def-infix-op-fn - (js::eval "a - b"))
;; (def-infix-op-fn * (js::eval "a * b"))
;; (def-infix-op-fn / (js::eval "a / b"))

(def (mod a b)
     (js::eval "a % b"))
(def pow ('pow Math))
(def abs ('abs Math))
(def (negate n)
     (js::eval "-n"))


;; LOGICAL
(defmacro (not x)
  (let (c-x (.compile-item oppo x)
        list* (lambda (...ls) ls)
        compiled (.join (list* "!" c-x) ""))
    `(js::eval ,compiled)))

(def-chained-operator or "||")
(def-chained-operator and "&&")


;; COMPARISON
(def-chained-operator < "<" and)
(def-chained-operator > ">" and)
(def-chained-operator <= "<=" and)
(def-chained-operator >= ">=" and)
(def-chained-operator eq "===" and)
(def-chained-operator not-eq "!==" and)
(def-chained-operator eq~ "==" and)
(def-chained-operator not-eq~ "!=" and)

(def = ('is-equal ('helpers oppo)))
(def (not=)
     (not (apply = (js::eval "arguments"))))

(def (nil? x) (eq~ x #nil))


;; GENERAL ENVIRONMENT
(let (stringify (lambda (x) (.to-oppo-string ('helpers oppo) x #f)))
  (def (puts ...args)
       (.apply ('log console) console (map stringify args)))
  (def (puts-error ...args)
       (.apply ('error console) console (map stringify args)))
  (def (puts-warning ...args)
       (.apply ('warn console) console (map stringify args))))

(defmacro (cond ...body)
  (let (len ('length body)
        fst (js::eval "body[0]")
        snd (js::eval "body[1]")
        rest (js::eval "body.slice(2)"))
    (if (js::eval "len % 2 !== 0") (js::eval "(function () { throw oppo.CompileError('Cannot call cond with an odd number of arguments', this); })"))
    (if len
        `(if ,fst ,snd (cond ,@rest)))))


;; GENERIC COLLECTION METHODS
(def (empty? x)
     (let (type (typeof x))
       (cond
        (nil? x) #t
        (or (eq type "array")
            (eq type "string")) (eq ('length x) 0)
        (eq type "object") (empty? (keys x))
        (eq type "number") (eq x 0)
        'else #f)))

(def contains? (js::eval "function (c, v, deep) {
  if (deep == null)
    deep = true;
  var is_equal, type, v2;

  is_equal = oppo.helpers.is_equal;
  type = oppo.helpers.to_type(c);
  if (type === 'array' || type === 'string') {
    if (!deep && c.indexOf) {
      return c.indexOf(v) >= 0
    } else {
      for (var i = 0, len = c.length; i < len; i++) {
        v2 = c[i];
        if (deep) {
          if (is_equal(v, v2))
            return true;
        } else {
          if (v === v2)
            return true;
        }
      }
    }
  } else if (type === 'object') {
    for (var prop in c) {
      v2 = c[prop]
      if (deep) {
        if (is_equal(v, v2))
          return true;
      } else {
        if (v === v2)
          return true;
      }
    }
  }

  return false;
}"))





;; LISTS
(def (list ...ls) ls)
(def (->list x) (js::eval "Array.prototype.slice.call(x)"))

(def map ('map ('helpers oppo)))

(def reduce (js::eval "function reduce(fn, ls) {
  var len = ls.length;
  if (len < 2)
    throw new Error('Can\\'t reduce list with fewer than two items');
  var ret = ls[0];
  for (var i = 1; i < len; i++) {
    ret = fn(ret, ls[i]);
  }
  return ret;
}"))

(def reduce-right (js::eval "function reduce_right(fn, ls) {
  var len = ls.length;
  if (len < 2)
    throw new Error('Can\\'t reduce-right list with fewer than two items');
  var ret = ls[len - 1];
  for (var i = len - 2; i >= 0; i--) {
    ret = fn(ret, ls[i]);
  }
  return ret;
}"))

(def filter (js::eval "function filter(fn, ls) {
  var ret, i, len, item;
  ret = [];
  for (i = 0, len = ls.length; i < len; i++) {
    item = ls[i];
    if (fn(item))
      ret.push(item)
  }
  return ret;
}"))

(def concat ('concat ('helpers oppo)))
(def (first ls) (js::eval "ls[0]"))
(def (second ls) (js::eval "ls[1]"))
(def (third ls) (js::eval "ls[2]"))

(def (nth ls n)
     (if (eq n 0)
         (do (puts-warning "nth treats lists as 1-based; accessing the 0th item will always yield #nil")
             #nil)
       (let (i (if (< n 0)
                   (+ ('length ls) n)
                   (- n 1)))
         (js::eval "ls[i]"))))


;; OBJECTS
(def object (js::eval "function () {
  var ret, i, len, key;
  ret = {};
  len = arguments.length;
  if (len % 2 !== 0)
    throw new Error('Object must have an even number of arguments (every key must have a value)');
  for (i = 0; i < len; i++) {
    if (i % 2 === 0)
      key = arguments[i];
    else
      ret[key] = arguments[i];
  }
  return ret;
}"))

(def (->object x) (Object x))

(let [-merge ('merge ('helpers oppo))]
     (def [merge ...objs]
          (apply -merge `[,(js::eval "{}") ,@objs])))

(def keys ('keys ('helpers oppo)))


;; STRINGS
(def (->string x) (String x))
(def (str ...strings) (.join strings ""))


;; NUMBERS
(def (->number x) (Number x))


;; BOOLEANS
(def (->boolean x) (Boolean x))
